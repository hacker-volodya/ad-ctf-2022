# Уязвимости Cloudy Days

## Path traversal
Делаем джарник, который читает файлы из сторейджа по пути `../имя_дроплета/flag`, получаем флаги. Так как логи доступны всем, желательно их зашифровать.

## Jar replacement
Создаём дроплет с существующим именем, джарник заменится. В своём джарнике делаем закладку, которая будет выгружать инфу в отдельный файл, и потом отдавать нам.
```
upd: уязвимость багнутая и не эксплуатируется, похоже что-то с кэшами файлов на линуксе (на винде норм работало). джарник заменяется в файловой системе, но в сервисе запускается старый.
```

## RCE
Используем малоизвестное апи `java.lang.invoke` для вызова запрещённых методов. В результате можем творить в контейнере всё что угодно, в примере просто запускаются шелл команды.


# Уязвимости Locator

## Переполнение буфера при загрузке репортов
Репорты загружались в бинарном виде с такой структурой:
```
String timestamp;
float lat;
float lon;
String location_format;
String comment;
```

String в свою очередь сериализуется как:
```
int length;
byte[] data;
```

Репорт при загрузке добавлялся в начало поля data, перед всеми остальными репортами. После этого data парсилась и сервис возвращал добавленный репорт в десериализованном виде. Если переполнить length, то в timestamp попадала вообще вся data, в том числе и добавленные ранее флаги в поле comment.

```
todo: сделать так, чтобы нельзя было эксплуатировать уязвимость вообще любым пэйлоадом, иначе получается слишком просто
```

## SpEL Injection
В репорте есть поле location_format, которое позволяет красиво форматировать локацию (lat и lon) в строку. Это поле представляет из себя выражение, написанное на Spring Expression Language. В сервисе используется StandardEvaluationContext, с которым из SpEL можно получить доступ к любым классам в Java. Если пользователь может как-то влиять на шаблоны SpEL, то возникает уязвимость [SpEL Injection](https://0xn3va.gitbook.io/cheat-sheets/framework/spring/spel-injection), через которую можно получить RCE в сервисе, например через выражение `#{T(java.lang.Runtime).getRuntime().exec('sleep 10')}`.

## Malformed JWT
В сервисе очень странно сериализуется JWT, его пэйлоад представляет из себя не нормальный JSON, а строку с JSON'ом, таким образом все кавычки и прочие спецсимволы эскейпятся. Чтобы раскодировать такой пэйлоад, сервис удаляет лишнее экранирование через String.replace. Если поэкспериментировать с пэйлоадом, можно заметить, что строка \rn в id маячка заменяется на пустую: при эскейпе \rn заменяется на \\rn, а дальше происходит замена "\\rn" -> "\n" -> "". Эту особенность можно использовать, чтобы добавлять новые маячки, у которых JWT-токен подходит к старым (чтобы получить секретную информацию для маячка abc, используем токен от маячка abc\\rn).

## Hardcoded secret
JWT подписывался секретом changeme, который был у всех одинаковым. Таким образом можно было подписывать валидные JWT для других команд.